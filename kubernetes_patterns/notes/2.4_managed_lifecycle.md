* Containerized applications managed by cloud-native platforms have no control over their lifecycle.
* To be good cloud-native citizens, they have to *listen to the events emitted by the managing platform* and adapt their lifecycles accordingly.

**Problem**
* Health-check APIs are ready-only endpoints the application is continually probing to get application insights.
* In addition to monitoring the state of a container, the platform may sometimes issue commands and expect the container to react on these. 
* It is up to the containerized application to determine which events are important to react to and how to react.

**Solution**
* Real-world applications require more fine-grained interactions and lifecycle management capabilities.
* Some applications need help to warm up, and some applications need a gentle and clean shutdown procedure.
* For this and other use cases, some events are emitted by the platform that the container can listen to and react to if desired.
* The events and hooks discussed here are all applied at an individual container level rather than pod level.

**SIGTERM signal**
* Whenever Kubernetes decides to shut down a container, the container receives a SIGTERM signal. Could be due to: 
    * Pod it belongs to is shutting down(could be because of deployment).
    * A failed liveness probe causes the container to be restarted.
* SIGTERM is a gentle poke for the container to shut down cleanly before the container sends a more abrupt SIGKILL signal.
* Once a SIGTERM signal has been received, the application should shut down as quickly as possible.
* For some applications, this might be a quick termination, and some applications may have to *complete their in-flight requests*, *release open connections*, and *clean up temp files*, which can take a slightly longer time.