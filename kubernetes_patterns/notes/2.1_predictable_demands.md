* We should declare application requirements whether they are hard runtime dependencies or resource requirements.
* It is essential for finding the right place for our application within the cluster.

**Problem**
* Different languages have different resource requirements. eg. compiled, static type faster than interpreted, dynamic typed languages.
* Considering that many modern programming languages in the same category have similar resource requirements, more important aspects are: domain, business logic, actual implementation details.

* It is difficult to predict the amount of resources a container may need to function optimally, and needs to be discovered by the developer through testing.
* Some services have a fixed CPU and memory consumption profile and some are spiky. Some services need persistent storage to store data. Some legacy services require a fixed port number on the host system to work correctly.

**Solution**
* Importance of knowing the runtime requirements for a container:
    1. *Help kubernetes make intelligent decisions*
        * With all the runtime dependencies and resource requirements defined, kubernetes can make intelligent decisions for where to place a container on the cluster for most efficient hardware utilization. 
        * In an environment with *shared resources* among a *large no. of processes* with *different priorities*, the only way for a *successful coexistence* is to know the *demands* of every process in advance.
    2. *Capacity Planning*
        * Will help to come up with the most cost-effective host profiles to satisfy the entire cluster demand.

**Runtime Dependencies**

**Resource Profiles**
* The resources are categorized as *compressible* (can be throttled such as CPU, or network bandwidth) and *incompressible* (cannot be throttled. eg. memory).
* Making the distinction between compressible and incompressible resources is important. If you containers consume too many compressible resources such as CPU, they are throttled. But if they consumer too many incompressible resources such as memory, they are killed (as there is no other way to ask an application to release allocated memory).

* We have to specify the following for our application:
    1. requests: the minimum amount of resources that are needed.
    2. limits: the maximum amount it can grow up to.

* The requests amount(but not limits) is used by the scheduler when placing Pods to nodes. For a given Pod, the scheduler only considers those nodes that still have enough capacity to accomodate the Pod and all of its containers by summing up the requested resource amounts.

* Depending on whether we specify the requests, the limits or both, we get different QoS(quality of service):

* *Best-Effort*: 
    * Pod that does not have any requests and limits set for its container.
    * Pod considered lowest priority and killed first when the node where the Pod is placed runs out of incompressible resource.

*Burstable*:
    * Pod that has requests and limits defined but they are not equal.
    * Likely to be killed if no best-effort pod remains.

*Guaranteed*:
    * Pod that has equal amount of requests and limit.
    * Highest priority.

* Hence defining resource requests and limits has a direct impact on the quality of service.
* kubectl apply -f kubernetes_patterns/hands_on/2.3_resource_limits.yaml
    pod/random-generator created